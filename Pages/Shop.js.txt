import React, { useState, useEffect } from 'react';
import { User, UserStats, Player, PlayerCard as PlayerCardEntity } from '@/entities/all';
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Coins, Package, Zap, Gift } from 'lucide-react';
import { motion, AnimatePresence } from 'framer-motion';
import CardPack from '../components/cards/CardPack';
import PlayerCard from '../components/cards/PlayerCard';

const PACK_TYPES = {
  basic: { name: 'Basic Pack', cost: 50, cards: 3, rareChance: 15, epicChance: 3, legendaryChance: 0.5 },
  premium: { name: 'Premium Pack', cost: 150, cards: 5, rareChance: 35, epicChance: 12, legendaryChance: 2 },
  legendary: { name: 'Legendary Pack', cost: 500, cards: 10, rareChance: 60, epicChance: 30, legendaryChance: 8 }
};

const SHOP_ITEMS = {
  upgrade_points: [
    { id: 'up_10', name: '10 Upgrade Points', cost: 100, amount: 10 },
    { id: 'up_50', name: '50 Upgrade Points', cost: 450, amount: 50 },
    { id: 'up_100', name: '100 Upgrade Points', cost: 800, amount: 100 },
  ],
};

const DAILY_REWARD = {
  coins: 50,
  upgrade_points: 5,
};

export default function ShopPage() {
  const [user, setUser] = useState(null);
  const [userStats, setUserStats] = useState(null);
  const [isOpening, setIsOpening] = useState(false);
  const [newCards, setNewCards] = useState([]);
  const [canClaimDaily, setCanClaimDaily] = useState(false);
  const [timeLeft, setTimeLeft] = useState('');

  useEffect(() => {
    loadData();
  }, []);

  useEffect(() => {
    if (!userStats) return;

    const checkDailyGift = () => {
      if (!userStats.last_daily_gift_claim) {
        setCanClaimDaily(true);
        return;
      }
      const lastClaim = new Date(userStats.last_daily_gift_claim);
      const now = new Date();
      const diff = now.getTime() - lastClaim.getTime();
      const hours = 24 - diff / (1000 * 60 * 60);

      if (hours <= 0) {
        setCanClaimDaily(true);
        setTimeLeft('');
      } else {
        setCanClaimDaily(false);
        const h = Math.floor(hours);
        const m = Math.floor((hours - h) * 60);
        setTimeLeft(`${h}h ${m}m left`);
      }
    };

    checkDailyGift();
    const interval = setInterval(checkDailyGift, 60000); // Check every minute
    return () => clearInterval(interval);
  }, [userStats]);

  const loadData = async () => {
    try {
      const userData = await User.me();
      setUser(userData);
      
      const statsData = await UserStats.list();
      if (statsData.length > 0) {
        setUserStats(statsData[0]);
      } else {
        const newStats = await UserStats.create({});
        setUserStats(newStats);
      }
    } catch (error) {
      console.error('Error loading data:', error);
    }
  };

  const generateCard = (packType) => {
    const packConfig = PACK_TYPES[packType];
    
    // Generate a random number between 0 and 100 for rarity check
    const rand = Math.random() * 100; 
    let rarity = 'common';
    
    // Determine rarity based on chances (higher chances are checked first, for exclusive ranges)
    if (rand < packConfig.legendaryChance) rarity = 'legendary';
    else if (rand < packConfig.epicChance) rarity = 'epic';
    else if (rand < packConfig.rareChance) rarity = 'rare';
    
    console.log(`Generated ${rarity} card (roll: ${rand.toFixed(2)})`);
    
    // Define stat ranges based on rarity
    const rarityStats = {
      common: { min: 35, max: 60 },
      rare: { min: 55, max: 75 },
      epic: { min: 70, max: 85 },
      legendary: { min: 80, max: 95 }
    }[rarity];
    
    const positions = ['goalkeeper', 'striker'];
    const position = positions[Math.floor(Math.random() * positions.length)];
    
    // Expanded name lists for more variety
    const firstNames = [
      'Marco', 'Diego', 'Alex', 'Roberto', 'Kevin', 'Carlos', 'Luis', 'Andre',
      'Miguel', 'David', 'Paulo', 'Fernando', 'Antonio', 'Juan', 'Pedro',
      'Rafael', 'Gabriel', 'Lucas', 'Mateo', 'Eduardo', 'Jose', 'Manuel'
    ];
    
    const lastNames = [
      'Silva', 'Torres', 'Chen', 'Martinez', 'Johnson', 'Mendoza', 'Garcia',
      'Santos', 'Rodriguez', 'Kim', 'Costa', 'Lopez', 'Ruiz', 'Morales',
      'Gonzalez', 'Oliveira', 'Pereira', 'da Silva', 'Rossi', 'Vargas'
    ];
    
    // Updated team list
    const teams = [
      'Real Madrid', 'Barcelona', 'Manchester United', 'Liverpool', 'Bayern Munich',
      'PSG', 'Chelsea', 'Arsenal', 'Juventus', 'AC Milan', 'Manchester City',
      'Atletico Madrid', 'Borussia Dortmund', 'Inter Milan', 'Napoli'
    ];
    
    // Updated abilities list
    const abilities = [
      'Power Shot', 'Curve Master', 'Lightning Speed', 'Perfect Timing',
      'Mental Focus', 'Pressure Immunity', 'Precision Strike', 'Goal Magnet',
      'Reflex Boost', 'Diving Expert', 'Shot Stopper', 'Command Area'
    ];
    
    // Updated countries list
    const countries = [
      'Brazil', 'Argentina', 'Spain', 'France', 'Germany', 'Italy',
      'England', 'Portugal', 'Netherlands', 'Belgium', 'Mexico', 'Colombia'
    ];
    
    return {
      name: `${firstNames[Math.floor(Math.random() * firstNames.length)]} ${lastNames[Math.floor(Math.random() * lastNames.length)]}`,
      position,
      rarity,
      // Generate stats within the rarity's min/max range, inclusive
      power: Math.floor(Math.random() * (rarityStats.max - rarityStats.min + 1)) + rarityStats.min,
      speed: Math.floor(Math.random() * (rarityStats.max - rarityStats.min + 1)) + rarityStats.min,
      accuracy: Math.floor(Math.random() * (rarityStats.max - rarityStats.min + 1)) + rarityStats.min,
      special_ability: abilities[Math.floor(Math.random() * abilities.length)],
      team: teams[Math.floor(Math.random() * teams.length)],
      nationality: countries[Math.floor(Math.random() * countries.length)]
    };
  };

  const openPack = async (packType) => {
    if (!userStats || isOpening) {
      console.log('Cannot open pack - no user stats or already opening');
      return;
    }
    
    const pack = PACK_TYPES[packType];
    const cost = pack.cost;
    const cardCount = pack.cards;
    
    if (userStats.coins < cost) {
      console.log(`Not enough coins: ${userStats.coins} < ${cost}`);
      return;
    }
    
    console.log(`Opening ${packType} pack for ${cost} coins`);
    setIsOpening(true);
    
    try {
      // Deduct coins immediately
      const newCoinAmount = userStats.coins - cost;
      await UserStats.update(userStats.id, {
        coins: newCoinAmount
      });
      
      // Update local state immediately to reflect deducted coins
      setUserStats(prev => ({ ...prev, coins: newCoinAmount }));
      
      // Generate new cards
      const generatedCards = [];
      for (let i = 0; i < cardCount; i++) {
        const cardData = generateCard(packType);
        console.log(`Generated card ${i + 1}:`, cardData);
        
        // Create player and link it to a PlayerCard entity
        const newPlayer = await Player.create(cardData);
        const newCard = await PlayerCardEntity.create({ 
          player_id: newPlayer.id,
          quantity: 1
        });
        generatedCards.push({ 
          ...newPlayer, 
          cardId: newCard.id, 
          isNew: true 
        });
      }
      
      console.log(`Successfully generated ${generatedCards.length} cards`);
      setNewCards(generatedCards);
      
      // Show cards animation for 5 seconds
      setTimeout(() => {
        setNewCards([]); // Clear new cards after animation
        setIsOpening(false); // Allow opening new packs
        loadData(); // Reload all data to reflect new cards in collection
        console.log('Pack opening complete');
      }, 5000); // Changed from 4000 to 5000
      
    } catch (error) {
      console.error('Error opening pack:', error);
      setIsOpening(false);
      
      // Refund coins on error
      if (userStats) {
        await UserStats.update(userStats.id, {
          coins: userStats.coins + cost
        });
        // Update local state to reflect refunded coins
        setUserStats(prev => ({ ...prev, coins: prev.coins + cost }));
      }
    }
  };
  
  const buyUpgradePoints = async (item) => {
    if (!userStats || userStats.coins < item.cost) {
      alert('Not enough coins!');
      return;
    }

    try {
      await UserStats.update(userStats.id, {
        coins: userStats.coins - item.cost,
        upgrade_points: userStats.upgrade_points + item.amount,
      });
      await loadData();
      alert(`Successfully purchased ${item.name}!`);
    } catch(e) {
      console.error("Purchase failed", e);
      alert("Purchase failed. Please try again.");
    }
  };

  const claimDailyGift = async () => {
    if (!canClaimDaily) return;

    try {
      await UserStats.update(userStats.id, {
        coins: userStats.coins + DAILY_REWARD.coins,
        upgrade_points: userStats.upgrade_points + DAILY_REWARD.upgrade_points,
        last_daily_gift_claim: new Date().toISOString(),
      });
      await loadData();
      alert(`You received ${DAILY_REWARD.coins} coins and ${DAILY_REWARD.upgrade_points} upgrade points!`);
    } catch (e) {
      console.error("Failed to claim daily gift", e);
    }
  };

  if (!user || !userStats) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <div className="animate-spin rounded-full h-32 w-32 border-b-2 border-purple-500"></div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900 p-4 md:p-8">
      <div className="max-w-7xl mx-auto">
        <div className="flex justify-between items-center mb-8">
          <div>
            <h1 className="text-3xl font-bold text-white">Shop</h1>
            <p className="text-purple-300 mt-1">Get packs, points, and more!</p>
          </div>
          <div className="flex items-center gap-6">
            <div className="flex items-center gap-2 bg-black/30 backdrop-blur-md rounded-lg px-4 py-2 border border-purple-500/20">
              <Zap className="w-5 h-5 text-green-400" />
              <span className="text-white font-bold">{userStats.upgrade_points}</span>
              <span className="text-purple-300">points</span>
            </div>
            <div className="flex items-center gap-2 bg-black/30 backdrop-blur-md rounded-lg px-4 py-2 border border-purple-500/20">
              <Coins className="w-5 h-5 text-yellow-500" />
              <span className="text-white font-bold">{userStats.coins}</span>
              <span className="text-purple-300">coins</span>
            </div>
          </div>
        </div>

        {/* Daily Gift Section */}
        <Card className="mb-8 bg-gradient-to-r from-yellow-500/20 to-orange-500/20 border border-yellow-500/30">
          <CardContent className="p-6 flex flex-col md:flex-row items-center justify-between gap-4">
            <div className="flex items-center gap-4">
              <Gift className="w-12 h-12 text-yellow-400" />
              <div>
                <h3 className="text-xl font-bold text-white">Daily Gift</h3>
                <p className="text-yellow-200">Claim your free reward every 24 hours!</p>
              </div>
            </div>
            <Button
              onClick={claimDailyGift}
              disabled={!canClaimDaily}
              className="bg-yellow-500 hover:bg-yellow-600 text-black font-bold w-full md:w-auto"
            >
              {canClaimDaily ? 'Claim Now' : `Claim in ${timeLeft}`}
            </Button>
          </CardContent>
        </Card>

        {/* Card Packs Section */}
        <div className="mb-8">
          <h2 className="text-2xl font-bold text-white mb-4">Card Packs</h2>
          <div className="text-center mb-6">
            <p className="text-purple-300">Different packs offer different chances for rare cards</p>
          </div>
          <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
            <CardPack
              packType="basic"
              onOpen={openPack}
              userCoins={userStats?.coins || 0}
              isOpening={isOpening}
            />
            <CardPack
              packType="premium"
              onOpen={openPack}
              userCoins={userStats?.coins || 0}
              isOpening={isOpening}
            />
            <CardPack
              packType="legendary"
              onOpen={openPack}
              userCoins={userStats?.coins || 0}
              isOpening={isOpening}
            />
          </div>
        </div>

        {/* Upgrade Points Section */}
        <div className="mb-8">
          <h2 className="text-2xl font-bold text-white mb-4">Upgrade Points</h2>
          <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
            {SHOP_ITEMS.upgrade_points.map(item => (
              <Card key={item.id} className="bg-black/20 backdrop-blur-md border border-purple-500/20">
                <CardHeader>
                  <CardTitle className="text-white flex items-center gap-2">
                    <Zap className="w-6 h-6 text-green-400" />
                    {item.name}
                  </CardTitle>
                </CardHeader>
                <CardContent className="flex flex-col justify-between h-full">
                  <div>
                    <p className="text-purple-300 mb-4">Instantly get points to level up your players.</p>
                  </div>
                  <div className="flex items-center justify-between">
                    <div className="flex items-center gap-2">
                      <Coins className="w-5 h-5 text-yellow-500" />
                      <span className="text-white font-bold text-lg">{item.cost}</span>
                    </div>
                    <Button onClick={() => buyUpgradePoints(item)} disabled={userStats.coins < item.cost}>
                      Buy Now
                    </Button>
                  </div>
                </CardContent>
              </Card>
            ))}
          </div>
        </div>

        {/* Pack Opening Animation */}
        <AnimatePresence>
          {newCards.length > 0 && (
            <motion.div
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              exit={{ opacity: 0 }}
              className="fixed inset-0 bg-black/80 backdrop-blur-sm flex items-center justify-center z-50"
            >
              <div className="max-w-6xl mx-auto p-8">
                <h2 className="text-4xl font-bold text-white text-center mb-8">New Cards!</h2>
                <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-5 gap-4">
                  {newCards.map((card, index) => (
                    <motion.div
                      key={card.cardId}
                      initial={{ scale: 0, rotateY: 180 }}
                      animate={{ scale: 1, rotateY: 0 }}
                      transition={{ delay: index * 0.2, duration: 0.6, type: "spring" }}
                    >
                      <PlayerCard player={{ ...card, cardInfo: { level: 1 } }} isNew={true} />
                    </motion.div>
                  ))}
                </div>
              </div>
            </motion.div>
          )}
        </AnimatePresence>
      </div>
    </div>
  );
}